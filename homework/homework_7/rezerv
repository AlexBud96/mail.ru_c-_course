#ifndef TNODE_H
#define TNODE_H

#include <iostream>


using namespace std;

template<class T>
struct TNode {
   T value;
   TNode *pleft, *pright;

   //constructor
   TNode() {
      pleft = pright = NULL;
   }
};

template<class T>
void delTree(TNode<T>* p) {
   if(p != NULL) {
      delTree(p->pleft);
      delTree(p->pright);
      delete p;
   }
}

template<class T>
void makeTree(TNode<T>** pp, T key) {
   if(*pp == NULL) {
      TNode<T>* p = new TNode<T>();
      p->value = key;
      *pp = p;
   }
   else {
      if((*pp)->value > key)
         makeTree(&((*pp)->pleft), key);
      else
         makeTree(&((*pp)->pright), key);
   }
}

template<class T>
void walkTree(TNode<T>* p) {
   if(p != NULL) {
      walkTree(p->pleft);
      cout << p->value << ' ';
      walkTree(p->pright);
   }
}

template<class T>
void copyTree(TNode<T>* p, TNode<T>** copy) {
   if(p != NULL) {
      copyTree(p->pleft, copy);
      makeTree(copy, p->value);
      copyTree(p->pright, copy);
   }
}

template<class T>
void foliage(TNode<T>* p) {
	if(p != NULL) {
      foliage(p->pleft);
      if(p->pleft == NULL and p->pright == NULL)
      		cout << p->value << ' ';
      foliage(p->pright);
   }
}

template<class T>
TNode<T>* findTree(TNode<T>* p, T key){
	if(p == NULL){
		return p;
	}
	if(p->value == key){
		return p;
	}
	if(p->value > key)
		return findTree(p->pleft, key);
	else
		return findTree(p->pright, key);
}

template<class T>
TNode<T>* findParentTree(TNode<T>* p, TNode<T>* child, TNode<T>* parent = NULL){
	if(p == NULL)
		return NULL;
	if(child == p)
		return parent;
	parent = p;
	if(child->value < p->value)
		return findParentTree(p->pleft, child, parent);
	else
		return findParentTree(p->pright, child, parent);
}

template<class T>
TNode<T>* minTree(TNode<T>* p){
	while(p->pleft != NULL)
		p = p->pleft;
	return p;
}

template<class T>
void replace_successor_node(TNode<T>* parent, TNode<T>* successor, TNode<T>* child = NULL){
	if(parent != NULL){
		if(successor == parent->pleft){
			parent->pleft = child;
			delete successor;
		}
		if(successor == parent->pright){
			parent->pright = child;
			delete successor;
		}
	}
}

template<class T>
void delNode(TNode<T>* p, T key){
	TNode<T>* s = p;
	if(key < p->value)
		delNodeRecursion(s, p->pleft, key);
	if(key > p->value)
		delNodeRecursion(s, p->pright, key);
	if(key == p->value){
		if(p->pleft != NULL and p->pright != NULL){
			TNode<T>* successor = minTree(p->pright);
			p->value = successor->value;
			delNodeRecursion(s, successor, successor->value);
		}
		else{
			if(p->pleft != NULL){
				TNode<T>* parent = findParentTree(s, p);
				replace_successor_node(parent, p, p->pleft);
			}
			if(p->pright != NULL){
				TNode<T>* parent = findParentTree(s, p);
				replace_successor_node(parent, p, p->pright);
			}
			if(p->pleft == NULL and p->pright == NULL){
				TNode<T>* parent = findParentTree(s, p);
				replace_successor_node(parent, p);
			}
		}
	}
}

template<class T>
void delNodeRecursion(TNode<T>* s, TNode<T>* p, T key){
	if(key < p->value)

		delNodeRecursion(s, p->pleft, key);
	if(key > p->value)
		delNodeRecursion(s, p->pright, key);
	if(key == p->value){
		if(p->pleft != NULL and p->pright != NULL){
			TNode<T>* successor = minTree(p->pright);
			p->value = successor->value;
			delNodeRecursion(s, successor, successor->value);
		}
		else{
			if(p->pleft != NULL){
				TNode<T>* parent = findParentTree(s, p);
				replace_successor_node(parent, p, p->pleft);
			}
			if(p->pright != NULL){
				TNode<T>* parent = findParentTree(s, p);
				replace_successor_node(parent, p, p->pright);
			}
			if(p->pleft == NULL and p->pright == NULL){
				TNode<T>* parent = findParentTree(s, p); 
				replace_successor_node(parent, p);
			}
			}
	}
}

#endif
